/* tslint:disable */
/* eslint-disable */
/**
 * fk-mitou-2024
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  HTTPValidationError,
  Problem,
  ProblemCreate,
  ProblemRead,
  ProblemReadByID,
  ProblemUpdate,
  Type,
} from '../models';
import {
  HTTPValidationErrorFromJSON,
  HTTPValidationErrorToJSON,
  ProblemFromJSON,
  ProblemToJSON,
  ProblemCreateFromJSON,
  ProblemCreateToJSON,
  ProblemReadFromJSON,
  ProblemReadToJSON,
  ProblemReadByIDFromJSON,
  ProblemReadByIDToJSON,
  ProblemUpdateFromJSON,
  ProblemUpdateToJSON,
  TypeFromJSON,
  TypeToJSON,
} from '../models';

export interface CreateProblemRequest {
  problemCreate: ProblemCreate;
}

export interface DeleteProblemRequest {
  id: number;
}

export interface ReadProblemByIdRequest {
  id: number;
}

export interface ReadProblemsRequest {
  skip?: number;
  limit?: number;
}

export interface UpdateProblemRequest {
  id: number;
  problemUpdate: ProblemUpdate;
}

/**
 * ProblemApi - interface
 *
 * @export
 * @interface ProblemApiInterface
 */
export interface ProblemApiInterface {
  /**
   * Create new problem with items.
   * @summary Create Problem
   * @param {ProblemCreate} problemCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  createProblemRaw(
    requestParameters: CreateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>>;

  /**
   * Create new problem with items.
   * Create Problem
   */
  createProblem(
    requestParameters: CreateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem>;

  /**
   * Delete a problem.
   * @summary Delete Problem
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  deleteProblemRaw(
    requestParameters: DeleteProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>>;

  /**
   * Delete a problem.
   * Delete Problem
   */
  deleteProblem(
    requestParameters: DeleteProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem>;

  /**
   * Retrieve problems.
   * @summary Read Item Type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  readItemTypeRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<Type>>>;

  /**
   * Retrieve problems.
   * Read Item Type
   */
  readItemType(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<Type>>;

  /**
   * Get problem by ID.
   * @summary Read Problem By Id
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  readProblemByIdRaw(
    requestParameters: ReadProblemByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ProblemReadByID>>;

  /**
   * Get problem by ID.
   * Read Problem By Id
   */
  readProblemById(
    requestParameters: ReadProblemByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ProblemReadByID>;

  /**
   * Retrieve problems.
   * @summary Read Problems
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  readProblemsRaw(
    requestParameters: ReadProblemsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<ProblemRead>>>;

  /**
   * Retrieve problems.
   * Read Problems
   */
  readProblems(
    requestParameters: ReadProblemsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<ProblemRead>>;

  /**
   * Get problem posts by ID.
   * @summary Update Problem
   * @param {number} id
   * @param {ProblemUpdate} problemUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProblemApiInterface
   */
  updateProblemRaw(
    requestParameters: UpdateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>>;

  /**
   * Get problem posts by ID.
   * Update Problem
   */
  updateProblem(
    requestParameters: UpdateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem>;
}

/**
 *
 */
export class ProblemApi extends runtime.BaseAPI implements ProblemApiInterface {
  /**
   * Create new problem with items.
   * Create Problem
   */
  async createProblemRaw(
    requestParameters: CreateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>> {
    if (
      requestParameters.problemCreate === null ||
      requestParameters.problemCreate === undefined
    ) {
      throw new runtime.RequiredError(
        'problemCreate',
        'Required parameter requestParameters.problemCreate was null or undefined when calling createProblem.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ProblemCreateToJSON(requestParameters.problemCreate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProblemFromJSON(jsonValue),
    );
  }

  /**
   * Create new problem with items.
   * Create Problem
   */
  async createProblem(
    requestParameters: CreateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem> {
    const response = await this.createProblemRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a problem.
   * Delete Problem
   */
  async deleteProblemRaw(
    requestParameters: DeleteProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteProblem.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/data/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProblemFromJSON(jsonValue),
    );
  }

  /**
   * Delete a problem.
   * Delete Problem
   */
  async deleteProblem(
    requestParameters: DeleteProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem> {
    const response = await this.deleteProblemRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve problems.
   * Read Item Type
   */
  async readItemTypeRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<Type>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/item_type`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(TypeFromJSON),
    );
  }

  /**
   * Retrieve problems.
   * Read Item Type
   */
  async readItemType(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<Type>> {
    const response = await this.readItemTypeRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get problem by ID.
   * Read Problem By Id
   */
  async readProblemByIdRaw(
    requestParameters: ReadProblemByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ProblemReadByID>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling readProblemById.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/data/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProblemReadByIDFromJSON(jsonValue),
    );
  }

  /**
   * Get problem by ID.
   * Read Problem By Id
   */
  async readProblemById(
    requestParameters: ReadProblemByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ProblemReadByID> {
    const response = await this.readProblemByIdRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve problems.
   * Read Problems
   */
  async readProblemsRaw(
    requestParameters: ReadProblemsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<ProblemRead>>> {
    const queryParameters: any = {};

    if (requestParameters.skip !== undefined) {
      queryParameters['skip'] = requestParameters.skip;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ProblemReadFromJSON),
    );
  }

  /**
   * Retrieve problems.
   * Read Problems
   */
  async readProblems(
    requestParameters: ReadProblemsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<ProblemRead>> {
    const response = await this.readProblemsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get problem posts by ID.
   * Update Problem
   */
  async updateProblemRaw(
    requestParameters: UpdateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Problem>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling updateProblem.',
      );
    }

    if (
      requestParameters.problemUpdate === null ||
      requestParameters.problemUpdate === undefined
    ) {
      throw new runtime.RequiredError(
        'problemUpdate',
        'Required parameter requestParameters.problemUpdate was null or undefined when calling updateProblem.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters['Authorization'] = await this.configuration.accessToken(
        'OAuth2PasswordBearer',
        [],
      );
    }

    const response = await this.request(
      {
        path: `/api/v1/problem/data/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ProblemUpdateToJSON(requestParameters.problemUpdate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProblemFromJSON(jsonValue),
    );
  }

  /**
   * Get problem posts by ID.
   * Update Problem
   */
  async updateProblem(
    requestParameters: UpdateProblemRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Problem> {
    const response = await this.updateProblemRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
